import { unpermissifyOptional } from "./unpermissify";
export class HookDomain {
    constructor() {
        this.withHooks = (rerender, getContextVariable, cb) => {
            this._position = 0;
            cb({
                useState: this._useStateHandler(rerender),
                useEffect: this._useEffectHandler,
                useContext: this._useContextHandler(getContextVariable),
                rerender: rerender,
            });
            if (this._position !== this._hookOrder.length) {
                throw new Error("Hooks are not in the right position!");
            }
            this._recording = false;
            this._position = undefined;
        };
        this._useStateHandler = (rerender) => (initialState) => {
            const hookIndex = this._position;
            this._position++;
            if (this._recording) {
                this._hookOrder[hookIndex] = "useState";
                this._useStateData[hookIndex] = initialState;
            }
            else if (this._hookOrder[hookIndex] !== "useState") {
                throw new Error("useState hook is not in the right position!");
            }
            const state = this._useStateData[hookIndex];
            // TODO: Make this stable
            const setState = (newState) => {
                this._useStateData[hookIndex] = newState;
                rerender();
            };
            return [state, setState];
        };
        this._useEffectHandler = (effect, deps) => {
            const hookIndex = this._position;
            this._position++;
            if (this._recording) {
                this._hookOrder[hookIndex] = "useEffect";
                this._useEffectData[hookIndex] = {
                    prevDepArray: unpermissifyOptional(deps),
                    prevDetach: undefined,
                };
            }
            else if (this._hookOrder[hookIndex] !== "useEffect") {
                throw new Error("useEffect hook is not in the right position!");
            }
            const { prevDepArray, prevDetach } = this._useEffectData[hookIndex];
            let shouldExecute = true;
            if (!deps) {
                shouldExecute = true;
            }
            else if (deps.length === 0 && !this._recording) {
                shouldExecute = false;
            }
            else if ((prevDepArray === null || prevDepArray === void 0 ? void 0 : prevDepArray.length) !== deps.length) {
                shouldExecute = true;
            }
            else {
                for (let i = 0; i < deps.length; i++) {
                    if (deps[i] !== prevDepArray[i]) {
                        shouldExecute = true;
                        break;
                    }
                }
            }
            this._useEffectData[hookIndex].prevDepArray = unpermissifyOptional(deps);
            if (shouldExecute) {
                prevDetach === null || prevDetach === void 0 ? void 0 : prevDetach();
                setTimeout(() => {
                    const detach = unpermissifyOptional(effect());
                    this._useEffectData[hookIndex].prevDetach = detach;
                }, 0);
            }
        };
        this._useContextHandler = (getContextVariable) => (context) => {
            const hookIndex = this._position;
            this._position++;
            if (this._recording) {
                this._hookOrder[hookIndex] = "useContext";
                this._useContextData[hookIndex] = context;
            }
            else if (this._hookOrder[hookIndex] !== "useContext" ||
                context !== this._useContextData[hookIndex]) {
                throw new Error("useContext hook is not in the right position!");
            }
            return getContextVariable(context);
        };
        this._recording = true;
        this._useStateData = [];
        this._useEffectData = [];
        this._useContextData = [];
        this._hookOrder = [];
        this._position = undefined;
    }
}
